<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Enhanced Mind Map App ‚Äì Touch Pan & Zoom</title>
  <style>
    /* Base styles */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    /* Toolbar */
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 1000;
      display: flex;
      gap: 5px;
    }
    #toolbar button {
      padding: 8px 12px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background: #007bff;
      color: #fff;
      border-radius: 4px;
    }
    #toolbar button:hover {
      background: #0056b3;
    }
    /* Export Menu */
    #exportMenu {
      display: none;
      position: fixed;
      top: 50px;
      left: 10px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 5px;
      z-index: 1001;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }
    #exportMenu button {
      padding: 5px 10px;
      margin: 2px;
      font-size: 14px;
      border: none;
      background: #007bff;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }
    #exportMenu button:hover {
      background: #0056b3;
    }
    /* Mind map container */
    #mindmap-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #f9f9f9;
      overflow: hidden;
      touch-action: none;
    }
    /* Scene for nodes (which is panned/zoomed) */
    #scene {
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: 0 0;
      width: 100%;
      height: 100%;
      z-index: 1; /* nodes above wires */
    }
    /* Node styling */
    .node {
      position: absolute;
      padding: 10px 15px;
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.1);
      user-select: none;
      cursor: grab;
      transition: box-shadow 0.2s, border-color 0.2s;
      z-index: 1; /* default stacking */
      display: inline-block;
    }
    .node.selected {
      border-color: #007bff;
      box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
      z-index: 1000; /* bring selected node (and its buttons) on top */
    }
    /* Node action buttons */
    .node .actions {
      position: absolute;
      top: -20px;
      right: -20px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 1001; /* ensure these buttons are above the node */
    }
    .node .actions button {
      width: 24px;
      height: 24px;
      padding: 0;
      border: none;
      background-color: #007bff;
      color: white;
      border-radius: 50%;
      font-size: 16px;
      cursor: pointer;
    }
    /* SVG overlay for connection wires (placed under the nodes) */
    #connections-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0; /* behind the scene */
    }
    /* Keyboard Help Overlay */
    #keyboardHelpOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: none;
      z-index: 3000;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
    }
    #keyboardHelpOverlay .content {
      max-width: 600px;
      margin: 0 auto;
      background: #333;
      padding: 20px;
      border-radius: 8px;
    }
    #keyboardHelpOverlay button.close {
      position: absolute;
      top: 20px;
      right: 20px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }
  </style>
  <!-- External Libraries for Exporting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image/2.6.0/dom-to-image.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <!-- Toolbar -->
  <div id="toolbar">
    <button id="addNodeBtn" title="Add Child">‚úö</button>
    <button id="addRootBtn" title="New Root Node">‚òÖ</button>
    <button id="zoomInBtn" title="Zoom In">Ôºã</button>
    <button id="zoomOutBtn" title="Zoom Out">Ôºç</button>
    <button id="zoomAllBtn" title="Zoom All">üîç</button>
    <button id="saveBtn" title="Save">üíæ</button>
    <button id="loadBtn" title="Load">üìÇ</button>
    <button id="newMindMapBtn" title="New Mind Map">üÜï</button>
    <button id="keyboardHelpBtn" title="Keyboard Shortcuts">‚å®</button>
    <!-- New Export Button -->
    <button id="exportBtn" title="Export Mind Map">‚§ì</button>
  </div>

  <!-- Export Menu -->
  <div id="exportMenu">
    <button id="exportPngBtn">Export as PNG</button>
    <button id="exportPdfBtn">Export as PDF</button>
    <button id="exportSvgBtn">Export as SVG</button>
  </div>

  <!-- Mind map container -->
  <div id="mindmap-container">
    <!-- The scene holds the nodes and is panned/zoomed -->
    <div id="scene"></div>
    <!-- The SVG sits behind the scene -->
    <svg id="connections-svg"></svg>
  </div>

  <!-- Keyboard Shortcuts Help Overlay -->
  <div id="keyboardHelpOverlay">
    <div class="content">
      <button class="close">&times;</button>
      <h2>Keyboard Shortcuts</h2>
      <ul>
        <li><strong>Ctrl+S</strong>: Save Mind Map</li>
        <li><strong>Ctrl+O</strong>: Load Mind Map</li>
        <li><strong>Ctrl+N</strong>: New Mind Map</li>
        <li><strong>Ctrl+E</strong>: Edit Selected Node Style</li>
        <li><strong>F2</strong>: Edit Selected Node Text</li>
        <li><strong>Delete</strong>: Remove Selected Node</li>
        <li><strong>Ctrl + "=" or "+"</strong>: Zoom In</li>
        <li><strong>Ctrl + "-"</strong>: Zoom Out</li>
        <li><strong>Ctrl+0</strong>: Zoom All</li>
        <li><strong>Arrow Keys</strong>: Pan View</li>
        <li><strong>Enter</strong> (in text/style editors): Confirm</li>
        <li><strong>Escape</strong> (in text/style editors or overlay): Cancel/Close</li>
      </ul>
    </div>
  </div>

  <script>
    function rgbToHex(rgb) {
      if (!rgb) return "#000000";
      if (rgb.startsWith("#")) return rgb;
      const result = rgb.match(/\d+/g);
      if (!result) return "#000000";
      return (
        "#" +
        result
          .slice(0, 3)
          .map((num) => parseInt(num, 10).toString(16).padStart(2, "0"))
          .join("")
      );
    }
    
    /***********************
     * MindMapNode Class
     * Represents a node in the mind map.
     ***********************/
    class MindMapNode {
      constructor({ id, text = 'Node', x = 100, y = 100, backgroundColor = '#fff', onSelect = () => {}, onDrag = () => {}, mindMap }) {
        this.id = id;
        this.text = text;
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.fixed = false;
        this.onSelect = onSelect;
        this.onDrag = onDrag;
        this.mindMap = mindMap;
        this.parent = null;
        this.children = [];
        this.lastTap = 0;  // For detecting double taps on touch devices.
        this.backgroundColor = backgroundColor;
        this.element = this._createElement();
        this._initDrag();
      }
      
      _createElement() {
        const nodeEl = document.createElement('div');
        nodeEl.classList.add('node');
        nodeEl.textContent = this.text;
        nodeEl.style.left = `${this.x}px`;
        nodeEl.style.top = `${this.y}px`;
        nodeEl.style.backgroundColor = this.backgroundColor;
        
        // Use pointer events so both mouse and touch work uniformly.
        nodeEl.addEventListener('pointerdown', (e) => {
          // If tapping on an action button, do nothing.
          if (e.target.closest('.actions')) return;
          e.stopPropagation();
          
          // For touch devices: detect a quick double-tap to edit text.
          if (e.pointerType === "touch") {
            const currentTime = Date.now();
            if (this.lastTap && (currentTime - this.lastTap) < 300) {
              this.editText();
              this.lastTap = 0;
              return; // Do not start drag on a double-tap.
            }
            this.lastTap = currentTime;
          }
          
          this.onSelect(this);
          this._startDrag(e);
        });
        // Double-click (for mouse) edits its text.
        nodeEl.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          this.editText();
        });
        return nodeEl;
      }
      
      _initDrag() {
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
      }
      
      _startDrag(e) {
        this.fixed = true;
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.initialX = this.x;
        this.initialY = this.y;
        this.element.setPointerCapture(e.pointerId);
        this.element.addEventListener('pointermove', this._onPointerMove);
        this.element.addEventListener('pointerup', this._onPointerUp);
        this.element.addEventListener('pointercancel', this._onPointerUp);
      }
      
      _onPointerMove(e) {
        const dx = e.clientX - this.startX;
        const dy = e.clientY - this.startY;
        this.setPosition(this.initialX + dx, this.initialY + dy);
        this.onDrag(this);
      }
      
      _onPointerUp(e) {
        this.fixed = false;
        this.element.releasePointerCapture(e.pointerId);
        this.element.removeEventListener('pointermove', this._onPointerMove);
        this.element.removeEventListener('pointerup', this._onPointerUp);
        this.element.removeEventListener('pointercancel', this._onPointerUp);
        this.mindMap.saveState();
      }
      
      setPosition(x, y) {
        this.x = x;
        this.y = y;
        this.element.style.left = `${x}px`;
        this.element.style.top = `${y}px`;
      }
      
      showActions() {
        if (this.element.querySelector('.actions')) return;
        const actionsDiv = document.createElement('div');
        actionsDiv.classList.add('actions');
        
        // "Add Child" button.
        const addBtn = document.createElement('button');
        addBtn.innerHTML = '+';
        addBtn.title = 'Add Child';
        addBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const childX = this.x + 100;
          const childY = this.y + 50;
          this.mindMap.addNode('New Idea', childX, childY, this);
        });
        
        // "Edit" button.
        const editBtn = document.createElement('button');
        editBtn.innerHTML = '‚úé';
        editBtn.title = 'Edit Text';
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.editText();
        });

        // "Edit Style" button.
        const styleBtn = document.createElement('button');
        styleBtn.innerHTML = 'üñå';
        styleBtn.title = 'Edit Style';
        styleBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.editStyle();
        });
        
        // "Remove" button.
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '‚àí';
        removeBtn.title = 'Remove Node';
        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.mindMap.removeNode(this);
        });
        
        actionsDiv.appendChild(addBtn);
        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(styleBtn);
        actionsDiv.appendChild(removeBtn);
        this.element.appendChild(actionsDiv);
      }
      
      hideActions() {
        const actionsDiv = this.element.querySelector('.actions');
        if (actionsDiv) {
          this.element.removeChild(actionsDiv);
        }
      }

      editText() {
        const originalText = this.text;
        const textInput = document.createElement("input");
        textInput.type = "text";
        textInput.value = this.text;

        // Get computed styles from the node.
        const computedStyle = window.getComputedStyle(this.element);
        textInput.style.fontSize = computedStyle.fontSize;
        textInput.style.fontFamily = computedStyle.fontFamily;
        textInput.style.fontWeight = computedStyle.fontWeight;
        textInput.style.border = "none";
        textInput.style.outline = "none";
        textInput.style.background = "transparent";
        textInput.style.padding = "0";
        textInput.style.margin = "0";
        textInput.style.display = "inline-block";

        // Function to update the width based on the content.
        const updateInputWidth = () => {
          const hiddenSpan = document.createElement("span");
          // Make sure the span uses the same styles.
          hiddenSpan.style.visibility = "hidden";
          hiddenSpan.style.position = "absolute";
          hiddenSpan.style.whiteSpace = "pre";
          hiddenSpan.style.fontFamily = textInput.style.fontFamily;
          hiddenSpan.style.fontSize = textInput.style.fontSize;
          hiddenSpan.style.fontWeight = textInput.style.fontWeight;
          hiddenSpan.textContent = textInput.value || textInput.placeholder || "";
          document.body.appendChild(hiddenSpan);
          // Add extra padding (e.g., 20px) for comfort.
          const newWidth = hiddenSpan.offsetWidth;
          textInput.style.width = newWidth + "px";
          document.body.removeChild(hiddenSpan);
        };

        updateInputWidth();
        textInput.addEventListener("input", updateInputWidth);

        // Replace the current text node with the input.
        if (this.element.firstChild && this.element.firstChild.nodeType === Node.TEXT_NODE) {
          this.element.replaceChild(textInput, this.element.firstChild);
        } else {
          this.element.insertBefore(textInput, this.element.firstChild);
        }
        textInput.focus();
        textInput.select();

        const finishEditing = () => {
          this.text = textInput.value;
          const textNode = document.createTextNode(this.text);
          this.element.replaceChild(textNode, textInput);
          this.mindMap.saveState();
        };

        const cancelEditing = () => {
          const textNode = document.createTextNode(originalText);
          this.element.replaceChild(textNode, textInput);
        };

        textInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            finishEditing();
          } else if (e.key === "Escape") {
            cancelEditing();
          }
        });
        textInput.addEventListener("blur", finishEditing);
      }

      editStyle() {
        // Get current computed styles.
        const computedStyle = window.getComputedStyle(this.element);
        const originalBackground =
          this.backgroundColor || computedStyle.backgroundColor || "#ffffff";
        const originalTextColor = computedStyle.color || "#000000";
        const originalFontSize = computedStyle.fontSize || "16px";

        // Store original style values for cancel.
        const origBg = originalBackground;
        const origText = originalTextColor;
        const origFs = originalFontSize;

        // Create a container for the floating style editor.
        const editor = document.createElement("div");
        editor.style.position = "absolute";
        editor.style.background = "#fff";
        editor.style.border = "1px solid #ccc";
        editor.style.padding = "5px";
        editor.style.boxShadow = "0 2px 4px rgba(0,0,0,0.2)";
        editor.style.zIndex = "2000";
        editor.style.minWidth = "150px";
        editor.style.fontFamily = "sans-serif";
        editor.style.fontSize = "12px";

        // --- Background Color Option ---
        const bgLabel = document.createElement("label");
        bgLabel.textContent = "Background: ";
        const bgInput = document.createElement("input");
        bgInput.type = "color";
        bgInput.value = originalBackground.startsWith("#")
          ? originalBackground
          : rgbToHex(originalBackground);
        bgInput.title = "Background Color";
        bgInput.style.cursor = "pointer";
        bgLabel.appendChild(bgInput);

        // --- Foreground (Text) Color Option ---
        const fgLabel = document.createElement("label");
        fgLabel.textContent = "Text: ";
        const fgInput = document.createElement("input");
        fgInput.type = "color";
        fgInput.value = originalTextColor.startsWith("#")
          ? originalTextColor
          : rgbToHex(originalTextColor);
        fgInput.title = "Text Color";
        fgInput.style.cursor = "pointer";
        fgLabel.appendChild(fgInput);

        // --- Font Size Option ---
        const fsLabel = document.createElement("label");
        fsLabel.textContent = "Font Size: ";
        const fsInput = document.createElement("input");
        fsInput.type = "number";
        fsInput.value = parseInt(originalFontSize, 10);
        fsInput.min = 8;
        fsInput.max = 72;
        fsInput.title = "Font Size (px)";
        fsInput.style.width = "60px";
        fsLabel.appendChild(fsInput);

        // --- Done and Cancel Buttons ---
        const doneButton = document.createElement("button");
        doneButton.textContent = "Done";
        doneButton.style.marginTop = "5px";
        doneButton.style.fontSize = "12px";
        doneButton.style.marginRight = "5px";
        
        const cancelButton = document.createElement("button");
        cancelButton.textContent = "Cancel";
        cancelButton.style.marginTop = "5px";
        cancelButton.style.fontSize = "12px";

        // --- Assemble the editor ---
        editor.appendChild(bgLabel);
        editor.appendChild(document.createElement("br"));
        editor.appendChild(fgLabel);
        editor.appendChild(document.createElement("br"));
        editor.appendChild(fsLabel);
        editor.appendChild(document.createElement("br"));
        editor.appendChild(doneButton);
        editor.appendChild(cancelButton);

        // Append the editor to the document body.
        document.body.appendChild(editor);

        // Position the editor relative to the node.
        const rect = this.element.getBoundingClientRect();
        editor.style.top = rect.bottom + "px";
        editor.style.left = rect.left + "px";

        // --- Event Listeners for Live Updates ---
        bgInput.addEventListener("input", (e) => {
          this.backgroundColor = e.target.value;
          this.element.style.backgroundColor = e.target.value;
        });
        fgInput.addEventListener("input", (e) => {
          this.element.style.color = e.target.value;
        });
        fsInput.addEventListener("input", (e) => {
          this.element.style.fontSize = e.target.value + "px";
        });

        // Keydown handler for the style editor.
        const styleKeydownHandler = (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            doneButton.click();
          } else if (e.key === "Escape") {
            e.preventDefault();
            cancelButton.click();
          }
        };
        document.addEventListener("keydown", styleKeydownHandler);

        // --- Button Handlers ---
        doneButton.addEventListener("click", () => {
          if (editor.parentElement) {
            editor.parentElement.removeChild(editor);
          }
          document.removeEventListener("keydown", styleKeydownHandler);
          this.mindMap.saveState();
        });

        cancelButton.addEventListener("click", () => {
          // Revert style changes.
          this.backgroundColor = origBg;
          this.element.style.backgroundColor = origBg;
          this.element.style.color = origText;
          this.element.style.fontSize = origFs;
          if (editor.parentElement) {
            editor.parentElement.removeChild(editor);
          }
          document.removeEventListener("keydown", styleKeydownHandler);
        });
      }
    }
    
    /***********************
     * MindMap Class
     * Manages nodes, connections, pan/zoom, simulation, and persistence.
     ***********************/
    class MindMap {
      constructor(containerId, sceneId, svgId) {
        this.container = document.getElementById(containerId);
        this.scene = document.getElementById(sceneId);
        this.svg = document.getElementById(svgId);
        this.nodes = new Map();
        this.connections = [];
        this.nodeCounter = 0;
        this.selectedNode = null;
        this.rootNodes = [];
        // Pan & zoom parameters.
        this.panX = 0;
        this.panY = 0;
        this.scale = 1;
        this.isPanning = false;
        this.panStartX = 0;
        this.panStartY = 0;
        this.startPanX = 0;
        this.startPanY = 0;
        // For pinch zoom.
        this.activePointers = new Map();
        this.initialPinchDistance = null;
        this.initialPinchScale = null;
        // Simulation parameters.
        this.simulation = {
          repulsion: 5000,
          springLength: 150,
          springStiffness: 0.05,
          friction: 0.90
        };
        // Initialize pan/zoom.
        this._initPanZoom();
        this._initWheelZoom();
        this._startSimulation();
      }
      
      addNode(text = 'Node', x = 150, y = 150, parentNode = null) {
        const id = `node-${this.nodeCounter++}`;
        const node = new MindMapNode({
          id,
          text,
          x,
          y,
          mindMap: this,
          onSelect: this._selectNode.bind(this),
          onDrag: () => { this.updateConnections(); }
        });
        this.nodes.set(id, node);
        this.scene.appendChild(node.element);
        if (parentNode) {
          node.parent = parentNode;
          parentNode.children.push(node);
          this.connections.push({ source: parentNode, target: node });
        } else {
          this.rootNodes.push(node);
        }
        this.updateConnections();
        this.saveState();
        return node;
      }
      
      _selectNode(node) {
        if (this.selectedNode && this.selectedNode !== node) {
          this.selectedNode.element.classList.remove('selected');
          this.selectedNode.hideActions();
        }
        this.selectedNode = node;
        node.element.classList.add('selected');
        node.showActions();
      }
      
      deselectNode() {
        if (this.selectedNode) {
          this.selectedNode.element.classList.remove('selected');
          this.selectedNode.hideActions();
          this.selectedNode = null;
        }
      }
      
      updateConnections() {
        // Clear previous connections.
        while (this.svg.firstChild) {
          this.svg.removeChild(this.svg.firstChild);
        }
        // Ensure SVG always fills the container.
        this.svg.setAttribute('width', this.container.clientWidth);
        this.svg.setAttribute('height', this.container.clientHeight);
        
        // Draw cubic B√©zier curves for connections.
        const containerRect = this.container.getBoundingClientRect();
        this.connections.forEach(({ source, target }) => {
          const sourceRect = source.element.getBoundingClientRect();
          const targetRect = target.element.getBoundingClientRect();
          const x1 = sourceRect.left - containerRect.left + sourceRect.width / 2;
          const y1 = sourceRect.top - containerRect.top + sourceRect.height / 2;
          const x2 = targetRect.left - containerRect.left + targetRect.width / 2;
          const y2 = targetRect.top - containerRect.top + targetRect.height / 2;
          
          // Calculate control points (25% and 75% along horizontal distance)
          const cp1x = x1 + (x2 - x1) * 0.25;
          const cp1y = y1;
          const cp2x = x1 + (x2 - x1) * 0.75;
          const cp2y = y2;
          
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          const d = `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
          path.setAttribute('d', d);
          path.setAttribute('stroke', '#888');
          path.setAttribute('stroke-width', '2');
          path.setAttribute('fill', 'none');
          path.setAttribute('stroke-linecap', 'round');
          // Keeps stroke width constant.
          path.setAttribute('vector-effect', 'non-scaling-stroke');
          this.svg.appendChild(path);
        });
      }
      
      removeNode(node) {
        if (node.children) {
          [...node.children].forEach(child => {
            this.removeNode(child);
          });
        }
        this.connections = this.connections.filter(conn => conn.source !== node && conn.target !== node);
        if (node.parent) {
          node.parent.children = node.parent.children.filter(child => child !== node);
        } else {
          this.rootNodes = this.rootNodes.filter(root => root !== node);
        }
        this.nodes.delete(node.id);
        if (node.element.parentElement) {
          node.element.parentElement.removeChild(node.element);
        }
        if (this.selectedNode === node) {
          this.selectedNode = null;
        }
        this.updateConnections();
        this.saveState();
      }
      
      /***********************
       * Pan & Zoom ‚Äì Improved for Touch & Mouse
       ***********************/
      _initPanZoom() {
        // Pointerdown for panning & pinch-zoom.
        this.container.addEventListener('pointerdown', (e) => {
          this.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
          // If the target is not a node, start panning.
          if (!e.target.closest('.node')) {
            this.isPanning = true;
            this.panStartX = e.clientX;
            this.panStartY = e.clientY;
            this.startPanX = this.panX;
            this.startPanY = this.panY;
          }
        });
        
        // Additional pointerdown listener to deselect a node when tapping empty space.
        this.container.addEventListener('pointerdown', (e) => {
          if (!e.target.closest('.node')) {
            this.deselectNode();
          }
        });
        
        this.container.addEventListener('pointermove', (e) => {
          if (this.activePointers.has(e.pointerId)) {
            this.activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
          }
          if (this.activePointers.size >= 2) {
            const points = Array.from(this.activePointers.values());
            if (!this.initialPinchDistance) {
              this.initialPinchDistance = Math.hypot(
                points[0].clientX - points[1].clientX,
                points[0].clientY - points[1].clientY
              );
              this.initialPinchScale = this.scale;
            } else {
              const currentDistance = Math.hypot(
                points[0].clientX - points[1].clientX,
                points[0].clientY - points[1].clientY
              );
              const newScale = this.initialPinchScale * (currentDistance / this.initialPinchDistance);
              const rect = this.container.getBoundingClientRect();
              const center = {
                x: ((points[0].clientX + points[1].clientX) / 2) - rect.left,
                y: ((points[0].clientY + points[1].clientY) / 2) - rect.top
              };
              const oldScale = this.scale;
              this.scale = Math.min(Math.max(newScale, 0.2), 5);
              this.panX = center.x - ((center.x - this.panX) * this.scale / oldScale);
              this.panY = center.y - ((center.y - this.panY) * this.scale / oldScale);
              this._updateTransform();
            }
          } else if (this.isPanning) {
            const dx = e.clientX - this.panStartX;
            const dy = e.clientY - this.panStartY;
            this.panX = this.startPanX + dx;
            this.panY = this.startPanY + dy;
            this._updateTransform();
          }
        });
        
        const pointerEndHandler = (e) => {
          this.activePointers.delete(e.pointerId);
          if (this.activePointers.size < 2) {
            this.initialPinchDistance = null;
            this.initialPinchScale = null;
          }
          if (e.target === this.container) {
            this.isPanning = false;
          }
        };
        this.container.addEventListener('pointerup', pointerEndHandler);
        this.container.addEventListener('pointercancel', pointerEndHandler);
      }
      
      _initWheelZoom() {
        this.container.addEventListener('wheel', (e) => {
          e.preventDefault();
          const rect = this.container.getBoundingClientRect();
          const pointerX = e.clientX - rect.left;
          const pointerY = e.clientY - rect.top;
          const oldScale = this.scale;
          this.scale *= (e.deltaY < 0 ? 1.1 : 0.9);
          this.scale = Math.min(Math.max(this.scale, 0.2), 5);
          this.panX = pointerX - ((pointerX - this.panX) * this.scale / oldScale);
          this.panY = pointerY - ((pointerY - this.panY) * this.scale / oldScale);
          this._updateTransform();
        });
      }
      
      _updateTransform() {
        this.scene.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
        // After transform, update connection wires.
        this.updateConnections();
      }
      
      zoomIn() {
        const rect = this.container.getBoundingClientRect();
        const pointerX = rect.width / 2;
        const pointerY = rect.height / 2;
        const oldScale = this.scale;
        this.scale *= 1.1;
        this.scale = Math.min(this.scale, 5);
        this.panX = pointerX - ((pointerX - this.panX) * this.scale / oldScale);
        this.panY = pointerY - ((pointerY - this.panY) * this.scale / oldScale);
        this._updateTransform();
      }
      
      zoomOut() {
        const rect = this.container.getBoundingClientRect();
        const pointerX = rect.width / 2;
        const pointerY = rect.height / 2;
        const oldScale = this.scale;
        this.scale *= 0.9;
        this.scale = Math.max(this.scale, 0.2);
        this.panX = pointerX - ((pointerX - this.panX) * this.scale / oldScale);
        this.panY = pointerY - ((pointerY - this.panY) * this.scale / oldScale);
        this._updateTransform();
      }
      
      zoomAll() {
        if (this.nodes.size === 0) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        this.nodes.forEach(node => {
          minX = Math.min(minX, node.x);
          minY = Math.min(minY, node.y);
          maxX = Math.max(maxX, node.x + node.element.offsetWidth);
          maxY = Math.max(maxY, node.y + node.element.offsetHeight);
        });
        const padding = 50;
        minX -= padding;
        minY -= padding;
        maxX += padding;
        maxY += padding;
        const containerRect = this.container.getBoundingClientRect();
        const width = maxX - minX;
        const height = maxY - minY;
        const scaleX = containerRect.width / width;
        const scaleY = containerRect.height / height;
        this.scale = Math.min(scaleX, scaleY, 5);
        this.panX = (containerRect.width - width * this.scale) / 2 - minX * this.scale;
        this.panY = (containerRect.height - height * this.scale) / 2 - minY * this.scale;
        this._updateTransform();
      }
      
      /***********************
       * Force-Directed Simulation
       ***********************/
      _startSimulation() {
        const simulate = () => {
          this._simulationTick();
          requestAnimationFrame(simulate);
        };
        simulate();
      }
      
      _simulationTick() {
        const nodesArray = Array.from(this.nodes.values());
        const forces = new Map();
        nodesArray.forEach(node => {
          forces.set(node.id, { fx: 0, fy: 0 });
        });

        // --- Repulsive Forces (between every pair) ---
        for (let i = 0; i < nodesArray.length; i++) {
          for (let j = i + 1; j < nodesArray.length; j++) {
            const n1 = nodesArray[i];
            const n2 = nodesArray[j];
            // (Optionally skip repulsion for isolated nodes.)
            if (
              (!n1.parent && n1.children.length === 0) ||
              (!n2.parent && n2.children.length === 0)
            ) {
              continue;
            }
            const dx = n1.x - n2.x;
            const dy = n1.y - n2.y;
            let distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
            const force = this.simulation.repulsion / (distance * distance);
            const fx = (dx / distance) * force;
            const fy = (dy / distance) * force;
            forces.get(n1.id).fx += fx;
            forces.get(n1.id).fy += fy;
            forces.get(n2.id).fx -= fx;
            forces.get(n2.id).fy -= fy;
          }
        }

        // --- Spring Forces (for connected nodes) ---
        this.connections.forEach(({ source, target }) => {
          const dx = target.x - source.x;
          const dy = target.y - source.y;
          let distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
          const difference = distance - this.simulation.springLength;
          const force = this.simulation.springStiffness * difference;
          const fx = (dx / distance) * force;
          const fy = (dy / distance) * force;
          forces.get(source.id).fx += fx;
          forces.get(source.id).fy += fy;
          forces.get(target.id).fx -= fx;
          forces.get(target.id).fy -= fy;
        });

        // --- Collision (Non-overlap) Forces ---
        const collisionForce = 0.7; // Adjust this value as needed.
        for (let i = 0; i < nodesArray.length; i++) {
          for (let j = i + 1; j < nodesArray.length; j++) {
            const nodeA = nodesArray[i];
            const nodeB = nodesArray[j];
            // Get bounding boxes based on the simulation coordinates.
            const ax = nodeA.x;
            const ay = nodeA.y;
            const aw = nodeA.element.offsetWidth;
            const ah = nodeA.element.offsetHeight;
            const bx = nodeB.x;
            const by = nodeB.y;
            const bw = nodeB.element.offsetWidth;
            const bh = nodeB.element.offsetHeight;

            // Check if boxes overlap.
            if (ax < bx + bw &&
                ax + aw > bx &&
                ay < by + bh &&
                ay + ah > by) {
              // Calculate overlap amounts in X and Y.
              const overlapX = Math.min(ax + aw, bx + bw) - Math.max(ax, bx);
              const overlapY = Math.min(ay + ah, by + bh) - Math.max(ay, by);
              // Apply force along the smallest overlap direction.
              if (overlapX < overlapY) {
                const sign = (ax + aw / 2 < bx + bw / 2) ? -1 : 1;
                forces.get(nodeA.id).fx += sign * overlapX * collisionForce;
                forces.get(nodeB.id).fx -= sign * overlapX * collisionForce;
              } else {
                const sign = (ay + ah / 2 < by + bh / 2) ? -1 : 1;
                forces.get(nodeA.id).fy += sign * overlapY * collisionForce;
                forces.get(nodeB.id).fy -= sign * overlapY * collisionForce;
              }
            }
          }
        }

        // --- Update Velocities and Positions ---
        nodesArray.forEach(node => {
          // Skip isolated nodes from simulation (if desired)
          if (!node.parent && node.children.length === 0) {
            node.vx = 0;
            node.vy = 0;
            return;
          }
          if (!node.fixed) {
            const f = forces.get(node.id);
            // Integrate forces with friction.
            node.vx = (node.vx + f.fx) * this.simulation.friction;
            node.vy = (node.vy + f.fy) * this.simulation.friction;

            // Limit maximum velocity for stability.
            const maxVelocity = 50;
            node.vx = Math.max(-maxVelocity, Math.min(maxVelocity, node.vx));
            node.vy = Math.max(-maxVelocity, Math.min(maxVelocity, node.vy));

            node.x += node.vx;
            node.y += node.vy;
            node.element.style.left = `${node.x}px`;
            node.element.style.top = `${node.y}px`;
          }
        });
        this.updateConnections();
      }

      /***********************
       * Persistence: Save, Load, and File I/O
       ***********************/
      getStateData() {
        const data = {
          nodes: [],
          panX: this.panX,
          panY: this.panY,
          scale: this.scale
        };
        this.nodes.forEach(node => {
          data.nodes.push({
            id: node.id,
            text: node.text,
            x: node.x,
            y: node.y,
            parent: node.parent ? node.parent.id : null,
            backgroundColor: node.backgroundColor
          });
        });
        return data;
      }
      
      saveState() {
        const data = this.getStateData();
        localStorage.setItem("mindMapState", JSON.stringify(data));
      }
      
      loadState() {
        const saved = localStorage.getItem("mindMapState");
        if (!saved) return;
        const data = JSON.parse(saved);
        this.loadStateFromObject(data);
      }
      
      loadStateFromObject(data) {
        // Remove any existing nodes.
        this.nodes.forEach(node => {
          if (node.element.parentElement) node.element.parentElement.removeChild(node.element);
        });
        this.nodes.clear();
        this.connections = [];
        this.rootNodes = [];
        this.nodeCounter = 0;
        const nodesById = {};
        // Create nodes with correct ids.
        data.nodes.forEach(n => {
          const node = this.addNode(n.text, n.x, n.y, null);
          // Remove the auto-generated id.
          this.nodes.delete(node.id);
          // Set the correct id.
          node.id = n.id;
          // Restore background color.
          node.backgroundColor = n.backgroundColor || '#fff';
          node.element.style.backgroundColor = node.backgroundColor;
          this.nodes.set(n.id, node);
          nodesById[n.id] = node;
        });
        // Re-establish connections.
        data.nodes.forEach(n => {
          if (n.parent) {
            const child = nodesById[n.id];
            const parent = nodesById[n.parent];
            child.parent = parent;
            parent.children.push(child);
            this.connections.push({ source: parent, target: child });
            this.rootNodes = this.rootNodes.filter(root => root !== child);
          }
        });
        let maxId = 0;
        data.nodes.forEach(n => {
          const num = parseInt(n.id.split('-')[1]);
          if (num > maxId) maxId = num;
        });
        this.nodeCounter = maxId + 1;
        this.panX = data.panX;
        this.panY = data.panY;
        this.scale = data.scale;
        this._updateTransform();
        this.updateConnections();
      }
      
      newMindMap() {
        this.nodes.forEach(node => {
          if (node.element.parentElement) node.element.parentElement.removeChild(node.element);
        });
        this.nodes.clear();
        this.connections = [];
        this.rootNodes = [];
        this.nodeCounter = 0;
        localStorage.removeItem("mindMapState");
        const rect = this.container.getBoundingClientRect();
        const x = (rect.width / 2 - 50 - this.panX) / this.scale;
        const y = (rect.height / 2 - 25 - this.panY) / this.scale;
        this.addNode("Central Idea", x, y);
        this.zoomAll();
      }
    }
    
    /***********************
     * Initialization
     ***********************/
    document.addEventListener('DOMContentLoaded', () => {
      const mindMap = new MindMap('mindmap-container', 'scene', 'connections-svg');
      window.mindMap = mindMap; // make it globally accessible for keyboard shortcuts
      
      // Toolbar button: Add Child.
      document.getElementById('addNodeBtn').addEventListener('click', () => {
        const parentNode = mindMap.selectedNode || mindMap.rootNodes[0];
        if (parentNode) {
          const newX = parentNode.x + 150;
          const newY = parentNode.y;
          mindMap.addNode('New Idea', newX, newY, parentNode);
        }
      });
      
      // Toolbar button: New Root Node.
      document.getElementById('addRootBtn').addEventListener('click', () => {
        const rect = document.getElementById('mindmap-container').getBoundingClientRect();
        const x = (rect.width / 2 - 50 - mindMap.panX) / mindMap.scale;
        const y = (rect.height / 2 - 25 - mindMap.panY) / mindMap.scale;
        mindMap.addNode('New Root', x, y);
      });
      
      // Zoom buttons.
      document.getElementById('zoomInBtn').addEventListener('click', () => {
        mindMap.zoomIn();
      });
      document.getElementById('zoomOutBtn').addEventListener('click', () => {
        mindMap.zoomOut();
      });
      document.getElementById('zoomAllBtn').addEventListener('click', () => {
        mindMap.zoomAll();
      });
      
      // File Save.
      document.getElementById('saveBtn').addEventListener('click', () => {
        mindMap.saveState();
        const data = mindMap.getStateData();
        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "mindmap.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert("Mind map saved to file!");
      });
      
      // File Load.
      document.getElementById('loadBtn').addEventListener('click', () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.addEventListener("change", (event) => {
          const file = event.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              mindMap.loadStateFromObject(data);
            } catch (err) {
              alert("Failed to load mind map: " + err);
            }
          };
          reader.readAsText(file);
        });
        input.click();
      });
      
      // New Mind Map.
      document.getElementById('newMindMapBtn').addEventListener('click', () => {
        if (confirm("Start a new mind map? Current changes will be lost.")) {
          mindMap.newMindMap();
        }
      });
      
      // Keyboard Help Overlay.
      const helpBtn = document.getElementById('keyboardHelpBtn');
      const helpOverlay = document.getElementById('keyboardHelpOverlay');
      const closeHelp = helpOverlay.querySelector('button.close');
      helpBtn.addEventListener('click', () => {
        helpOverlay.style.display = "block";
      });
      closeHelp.addEventListener('click', () => {
        helpOverlay.style.display = "none";
      });
      
      /***********************
       * Export Functionality
       ***********************/
      const exportMenu = document.getElementById('exportMenu');
      
      // Toggle the export menu when the export button is clicked.
      document.getElementById('exportBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        exportMenu.style.display = exportMenu.style.display === 'none' ? 'block' : 'none';
      });
      
      // Hide export menu if clicking outside.
      document.addEventListener('click', (e) => {
        if (!exportMenu.contains(e.target) && e.target.id !== 'exportBtn') {
          exportMenu.style.display = 'none';
        }
      });
      
      // Export as PNG.
      document.getElementById('exportPngBtn').addEventListener('click', () => {
        const container = document.getElementById('mindmap-container');
        domtoimage.toPng(container)
          .then(function (dataUrl) {
            const a = document.createElement('a');
            a.download = 'mindmap.png';
            a.href = dataUrl;
            a.click();
          })
          .catch(function (error) {
            console.error('Export to PNG failed!', error);
          });
        exportMenu.style.display = 'none';
      });
      
      // Export as PDF.
      document.getElementById('exportPdfBtn').addEventListener('click', () => {
        const container = document.getElementById('mindmap-container');
        domtoimage.toPng(container)
          .then(function (dataUrl) {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('landscape');
            const imgProps = pdf.getImageProperties(dataUrl);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
            pdf.addImage(dataUrl, 'PNG', 0, 0, pdfWidth, pdfHeight);
            pdf.save('mindmap.pdf');
          })
          .catch(function (error) {
            console.error('Export to PDF failed!', error);
          });
        exportMenu.style.display = 'none';
      });
      
      // Export as SVG.
      document.getElementById('exportSvgBtn').addEventListener('click', () => {
        const container = document.getElementById('mindmap-container');
        domtoimage.toSvg(container)
          .then(function (dataUrl) {
            const a = document.createElement('a');
            a.download = 'mindmap.svg';
            a.href = dataUrl;
            a.click();
          })
          .catch(function (error) {
            console.error('Export to SVG failed!', error);
          });
        exportMenu.style.display = 'none';
      });
      
      // Global Keyboard Shortcuts.
      document.addEventListener("keydown", function(e) {
        // Do not trigger global shortcuts if focus is on an input or textarea.
        if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable) return;
        
        // If the keyboard help overlay is open, allow Escape to close it.
        if (helpOverlay.style.display === "block") {
          if (e.key === "Escape") {
            e.preventDefault();
            helpOverlay.style.display = "none";
          }
          return;
        }
        
        if (e.ctrlKey) {
          switch(e.key.toLowerCase()) {
            case 's':
              e.preventDefault();
              document.getElementById("saveBtn").click();
              break;
            case 'o':
              e.preventDefault();
              document.getElementById("loadBtn").click();
              break;
            case 'n':
              e.preventDefault();
              document.getElementById("newMindMapBtn").click();
              break;
            case 'e':
              e.preventDefault();
              if (mindMap.selectedNode) {
                mindMap.selectedNode.editStyle();
              }
              break;
            case '=':
            case '+':
              e.preventDefault();
              document.getElementById("zoomInBtn").click();
              break;
            case '-':
              e.preventDefault();
              document.getElementById("zoomOutBtn").click();
              break;
            case '0':
              e.preventDefault();
              document.getElementById("zoomAllBtn").click();
              break;
          }
        } else {
          if (e.key === "Delete" || e.key === "Backspace") {
              e.preventDefault();
              if (mindMap.selectedNode) {
                  mindMap.removeNode(mindMap.selectedNode);
              }
          } else if (e.key === "F2") {
              e.preventDefault();
              if (mindMap.selectedNode) {
                  mindMap.selectedNode.editText();
              }
          } else if (e.key === "ArrowUp") {
              e.preventDefault();
              mindMap.panY += 20;
              mindMap._updateTransform();
          } else if (e.key === "ArrowDown") {
              e.preventDefault();
              mindMap.panY -= 20;
              mindMap._updateTransform();
          } else if (e.key === "ArrowLeft") {
              e.preventDefault();
              mindMap.panX += 20;
              mindMap._updateTransform();
          } else if (e.key === "ArrowRight") {
              e.preventDefault();
              mindMap.panX -= 20;
              mindMap._updateTransform();
          }
        }
      });
      
      // Auto-load saved state or create an initial node.
      if (localStorage.getItem("mindMapState")) {
        mindMap.loadState();
      } else {
        const containerRect = document.getElementById('mindmap-container').getBoundingClientRect();
        const rootX = (containerRect.width / 2 - 50) / mindMap.scale;
        const rootY = (containerRect.height / 2 - 25) / mindMap.scale;
        mindMap.addNode('Central Idea', rootX, rootY);
      }
      
      // Zoom All on startup.
      mindMap.zoomAll();
    });
  </script>
</body>
</html>
